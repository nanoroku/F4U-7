window.gLocalAssetContainer["node_modules/@akashic-extension/resolve-player-info/lib/index.js"] = function(g) { (function(exports, require, module, __filename, __dirname) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePlayerInfo = void 0;
var FallbackDialog_1 = require("./FallbackDialog");
function createRandomName() {
    return "ゲスト" + ((Math.random() * 1000) | 0);
}
var resolvers = [
    // coeLimited
    {
        isSupported: function () {
            var coeLimited = g.game.external.coeLimited;
            return !!(coeLimited && coeLimited.startLocalSession && coeLimited.exitLocalSession);
        },
        resolve: function (limitSeconds, callback) {
            var sessionId = g.game.playId + "__player-info-resolver";
            var scene = g.game.scene();
            var timeoutId = scene.setTimeout(function () {
                timeoutId = null;
                // NOTE: スキップ時は既に終了済みのローカルセッション自体が起動せず messageHandler() も呼ばれなるため、
                // ここで callback() を呼ばないとコンテンツ側がコールバックをいつまでも待ってしまう状態になってしまう
                callback(null, {
                    name: null,
                    userData: { accepted: false, premium: false }
                });
                // NOTE: リアルタイム視聴の場合、大半のケースではこちらのパスには到達しないはず
                // (仮に到達しても同一セッションIDの COE#exitSession() が呼ばれるのみ)
                // 追っかけ再生またはタイムシフトによる視聴においては、
                // player-info-resolver の自発終了よりも先に以下の exitLocalSession() を呼ぶことで
                // 「スキップ中のセッション起動を抑止する」というプラットフォーム側の機能を有効にしている
                g.game.external.coeLimited.exitLocalSession(sessionId, { needsResult: true });
            }, (limitSeconds + 2) * 1000); // NOTE: 読み込みなどを考慮して 2 秒のバッファを取る
            g.game.external.coeLimited.startLocalSession({
                sessionId: sessionId,
                applicationName: "player-info-resolver",
                localEvents: [
                    [
                        32,
                        0,
                        ":akashic",
                        { type: "start", parameters: { limitSeconds: limitSeconds } }
                    ]
                ],
                messageHandler: function (message) {
                    if (timeoutId == null) { // 先にタイムアウト処理が実行されていたら何もしない
                        return;
                    }
                    scene.clearTimeout(timeoutId);
                    // TODO 引数からエラーを取得できるようになったら、異常系の処理も行う
                    callback(null, message.result);
                }
            });
        }
    },
    // FallbackDialog
    {
        isSupported: FallbackDialog_1.FallbackDialog.isSupported,
        resolve: function (limitSeconds, callback) {
            var name = createRandomName();
            var dialog = new FallbackDialog_1.FallbackDialog(name);
            dialog.start(limitSeconds);
            dialog.onEnd.addOnce(function () {
                callback(null, { name: name, userData: { accepted: false, premium: false } });
            });
        }
    },
    // sentinel
    {
        isSupported: function () { return true; },
        resolve: function (_limitSeconds, callback) {
            callback(null, {
                name: "",
                userData: {
                    accepted: false,
                    premium: false,
                    unnamed: true
                }
            });
        }
    }
];
var DEFAULT_LIMIT_SECONDS = 15;
// resolvePlayerInfo() の多重呼び出し防止フラグ
var isResolving = false;
function find(xs, pred) {
    for (var i = 0; i < xs.length; ++i) {
        if (pred(xs[i]))
            return xs[i];
    }
    return undefined;
}
/**
 * ユーザー情報の取得と通知を行う
 * @param opts ユーザ情報取得時のオプション
 * @param callback 指定された場合、playerInfo が取得成功・失敗した時点の次の local/non-local tick で呼び出される
 */
exports.resolvePlayerInfo = function (opts, callback) {
    if (isResolving) {
        callback === null || callback === void 0 ? void 0 : callback(new Error("Last processing has not yet been completed."), null);
        return;
    }
    var cb = function (err, info) {
        isResolving = false;
        callback === null || callback === void 0 ? void 0 : callback(err, info);
        if (!err) {
            var _a = info, name_1 = _a.name, userData = _a.userData;
            if (opts && opts.raises && (!userData || !userData.unnamed)) {
                g.game.raiseEvent(new g.PlayerInfoEvent({ id: g.game.selfId, name: name_1, userData: userData }));
            }
        }
    };
    var limitSeconds = opts && opts.limitSeconds ? opts.limitSeconds : DEFAULT_LIMIT_SECONDS;
    var resolver = find(resolvers, function (r) { return r.isSupported(); }); // isSupported() が恒真の実装があるので non-null
    try {
        isResolving = true;
        resolver.resolve(limitSeconds, cb);
    }
    catch (e) {
        cb(e);
    }
};

})(g.module.exports, g.module.require, g.module, g.filename, g.dirname);
}